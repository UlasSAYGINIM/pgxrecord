// Package pgxrecord is a tiny framework for CRUD operations and data mapping.
package pgxrecord

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgsql"
	"github.com/jackc/pgx/v4"
)

type Queryer interface {
	Query(ctx context.Context, sql string, optionsAndArgs ...interface{}) (pgx.Rows, error)
}

type Op int8

const (
	unspecifiedOp Op = iota
	InsertOp
	UpdateOp
)

type BeforeSaver interface {
	// BeforeSave returns an error if the operation should be canceled. op is either InsertOp or UpdateOp.
	BeforeSave(op Op) error
}

type Inserter interface {
	// InsertQuery returns the sql and query arguments used to insert the record.
	InsertQuery() (sql string, queryArgs []interface{})
}

type InsertScanner interface {
	// InsertScan scans the row generated by the returning clause into the record.
	InsertScan(pgx.Rows) error
}

type Updater interface {
	// UpdateQuery returns the sql and query arguments used to update the record.
	UpdateQuery() (sql string, queryArgs []interface{})
}

type UpdateScanner interface {
	// UpdateScan scans the row generated by the returning clause into the record.
	UpdateScan(pgx.Rows) error
}

type Deleter interface {
	// UpdateQuery returns the sql and query arguments used to delete the record.
	DeleteQuery() (sql string, queryArgs []interface{})
}

type DeleteScanner interface {
	// DeleteScan scans the row generated by the returning clause into the record.
	DeleteScan(pgx.Rows) error
}

type Selector interface {
	// SelectStatementOptions returns statement options to build a query that selects a record or records.
	SelectStatementOptions() []pgsql.StatementOption

	// SelectScan scans the current row into the record.
	SelectScan(pgx.Rows) error
}

type SelectCollection interface {
	// Add adds a Selector to the collection and returns it.
	Add() Selector
}

type PgErrorMapper interface {
	// MapPgError converts a pgconn.PgError to another type of error. For example, a unique constraint violation may be
	// converted to an application specific validation error.
	MapPgError(*pgconn.PgError) error
}

func tryMapPgError(record interface{}, err error) error {
	if mapper, ok := record.(PgErrorMapper); ok {
		if pgErr, ok := err.(*pgconn.PgError); ok {
			return mapper.MapPgError(pgErr)
		}
	}

	return err
}

type multipleRowsError struct {
	rowCount int64
}

func (e *multipleRowsError) Error() string {
	return fmt.Sprintf("expected 1 row got %d", e.rowCount)
}

type notFoundError struct{}

func (e *notFoundError) Error() string {
	return "not found"
}

// NotFound returns true if err is a not found error.
func NotFound(err error) bool {
	_, ok := err.(*notFoundError)
	return ok
}

// Insert inserts record into db. If record implements BeforeSaver then BeforeSave will be called. If an error is
// returned the Insert is aborted.
func Insert(ctx context.Context, db Queryer, record Inserter) error {
	if bs, ok := record.(BeforeSaver); ok {
		err := bs.BeforeSave(InsertOp)
		if err != nil {
			return err
		}
	}

	sql, queryArgs := record.InsertQuery()

	rows, err := db.Query(ctx, sql, queryArgs...)
	if err != nil {
		return err
	}

	for rows.Next() {
		if record, ok := record.(InsertScanner); ok {
			err = record.InsertScan(rows)
			if err != nil {
				rows.Close()
				return tryMapPgError(record, err)
			}
		}
	}
	if rows.Err() != nil {
		return tryMapPgError(record, rows.Err())
	}

	rowsAffected := rows.CommandTag().RowsAffected()
	if rowsAffected == 0 {
		return &notFoundError{}
	}
	if rowsAffected > 1 {
		return &multipleRowsError{rowCount: rowsAffected}
	}

	return nil
}

// Update updates record in db. If record implements BeforeSaver then BeforeSave will be called. If an error is
// returned the Update is aborted. If the update query does not affect exactly one record an error will be returned.
func Update(ctx context.Context, db Queryer, record Updater) error {
	if bs, ok := record.(BeforeSaver); ok {
		err := bs.BeforeSave(UpdateOp)
		if err != nil {
			return err
		}
	}

	sql, queryArgs := record.UpdateQuery()

	rows, err := db.Query(ctx, sql, queryArgs...)
	if err != nil {
		return err
	}

	for rows.Next() {
		if record, ok := record.(UpdateScanner); ok {
			err = record.UpdateScan(rows)
			if err != nil {
				rows.Close()
				return tryMapPgError(record, err)
			}
		}
	}
	if rows.Err() != nil {
		return tryMapPgError(record, rows.Err())
	}

	rowsAffected := rows.CommandTag().RowsAffected()
	if rowsAffected == 0 {
		return &notFoundError{}
	}
	if rowsAffected > 1 {
		return &multipleRowsError{rowCount: rowsAffected}
	}

	return nil
}

// Delete deletes record in db. If the delete query does affect exactly one record an error will be returned.
func Delete(ctx context.Context, db Queryer, record Deleter) error {
	sql, queryArgs := record.DeleteQuery()

	rows, err := db.Query(ctx, sql, queryArgs...)
	if err != nil {
		return err
	}

	for rows.Next() {
		if record, ok := record.(DeleteScanner); ok {
			err = record.DeleteScan(rows)
			if err != nil {
				rows.Close()
				return tryMapPgError(record, err)
			}
		}
	}
	if rows.Err() != nil {
		return tryMapPgError(record, rows.Err())
	}

	rowsAffected := rows.CommandTag().RowsAffected()
	if rowsAffected == 0 {
		return &notFoundError{}
	}
	if rowsAffected > 1 {
		return &multipleRowsError{rowCount: rowsAffected}
	}

	return nil
}

// SelectOne selects a single record from db into record. It applies options to the SQL statement. An error will be
// returned if no rows are found. Check for this case with the NotFound function. If multiple rows are selected an
// error will be returned.
func SelectOne(ctx context.Context, db Queryer, record Selector, options ...pgsql.StatementOption) error {
	stmt := pgsql.NewStatement()

	recordOptions := record.SelectStatementOptions()
	err := stmt.Apply(recordOptions...)
	if err != nil {
		return err
	}

	err = stmt.Apply(options...)
	if err != nil {
		return err
	}

	rows, err := db.Query(ctx, stmt.String(), stmt.Args.Values()...)
	if err != nil {
		return tryMapPgError(record, err)
	}

	rowCount := int64(0)
	for rows.Next() {
		if rowCount == 0 {
			err := record.SelectScan(rows)
			if err != nil {
				return err
			}
		}

		rowCount++
	}
	if rows.Err() != nil {
		return tryMapPgError(record, rows.Err())
	}

	if rowCount == 0 {
		return &notFoundError{}
	}

	if rowCount > 1 {
		return &multipleRowsError{rowCount: rowCount}
	}

	return nil
}

// SelectAll selects records from db into collection. It applies options to the SQL statement.
func SelectAll(ctx context.Context, db Queryer, collection SelectCollection, options ...pgsql.StatementOption) error {
	stmt := pgsql.NewStatement()

	record := collection.Add()
	recordOptions := record.SelectStatementOptions()
	err := stmt.Apply(recordOptions...)
	if err != nil {
		return err
	}

	err = stmt.Apply(options...)
	if err != nil {
		return err
	}

	rows, err := db.Query(ctx, stmt.String(), stmt.Args.Values()...)
	if err != nil {
		return tryMapPgError(record, err)
	}

	rowCount := 0
	for rows.Next() {
		if rowCount > 0 {
			record = collection.Add()
		}
		err := record.SelectScan(rows)
		if err != nil {
			return err
		}

		rowCount++
	}
	if rows.Err() != nil {
		return tryMapPgError(record, rows.Err())
	}

	return nil
}
